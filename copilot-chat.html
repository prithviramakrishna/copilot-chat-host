<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Copilot Chat</title>
  <script src="https://cdn.botframework.com/botframework-webchat/latest/webchat.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      font-family: 'Segoe UI', sans-serif;
    }

    #webchat {
      height: 100%;
      width: 100%;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <div id="webchat"></div>

  <script>
    const TOKEN_EXPIRY_MS = 29 * 60 * 1000;
    const apiVersion = '2022-03-01-preview';
    const botId = 'cr5d4_agent1';
    const tokenEndpoint = `https://ac9995b4c763e323b7d7f36b8dfee2.07.environment.api.powerplatform.com/powervirtualagents/botsbyschema/${botId}/directline/token?api-version=${apiVersion}`;
    const settingsEndpoint = `https://ac9995b4c763e323b7d7f36b8dfee2.07.environment.api.powerplatform.com/powervirtualagents/regionalchannelsettings?api-version=${apiVersion}`;

    let directLine, connectionSub;

    async function getNewTokenAndDomain() {
      const [tokenRes, settingsRes] = await Promise.all([
        fetch(tokenEndpoint).then(r => r.json()),
        fetch(settingsEndpoint).then(r => r.json())
      ]);
      const token = tokenRes.token;
      const domain = new URL('v3/directline', settingsRes.channelUrlsById.directline).toString();
      return { token, domain, tokenTimestamp: Date.now() };
    }

    async function startWebChat(incidentId) {
      const cacheKey = `chat_${incidentId}`;
      const cache = JSON.parse(sessionStorage.getItem(cacheKey) || '{}');
      let { token, domain, tokenTimestamp, conversationId } = cache;
      const isTokenValid = token && (Date.now() - (tokenTimestamp || 0) < TOKEN_EXPIRY_MS);

      // If token is invalid or missing, fetch a new one
      if (!isTokenValid || !token || !domain) {
        const fresh = await getNewTokenAndDomain();
        token = fresh.token;
        domain = fresh.domain;
        tokenTimestamp = fresh.tokenTimestamp;
        conversationId = null;
        sessionStorage.setItem(cacheKey, JSON.stringify({ token, domain, tokenTimestamp }));
        console.log("🔁 New token fetched for", incidentId);
      } else {
        console.log("✅ Reusing token for", incidentId);
      }

      // Clean up before creating new chat
      if (connectionSub) connectionSub.unsubscribe();
      if (directLine?.end) directLine.end();

      directLine = WebChat.createDirectLine({
        token,
        domain,
        ...(conversationId ? { conversationId } : {})
      });

      connectionSub = directLine.connectionStatus$.subscribe(status => {
        if (status === 2) {
          if (!conversationId && directLine.conversationId) {
            const updated = JSON.parse(sessionStorage.getItem(cacheKey) || '{}');
            updated.conversationId = directLine.conversationId;
            sessionStorage.setItem(cacheKey, JSON.stringify(updated));
          }

          directLine.postActivity({
            type: 'event',
            name: 'startConversation',
            from: { id: 'user' },
            value: { incidentId }
          }).subscribe();
        }
      });

      WebChat.renderWebChat({
        directLine,
        locale: 'en',
        userID: 'user',
        styleOptions: {
          hideUploadButton: false,
          botAvatarInitials: 'BF',
          botAvatarBackgroundColor: '#001931',
          userAvatarBackgroundColor: 'gold',
          userAvatarInitials: 'You'
        }
      }, document.getElementById('webchat'));
    }

    // Example incidentId — replace this with real OpenFrame context message handling
    const incidentId = new URLSearchParams(window.location.search).get("incidentId") || "default_incident_123";
    startWebChat(incidentId);
  </script>
</body>
</html>
