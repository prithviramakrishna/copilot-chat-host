<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Copilot Chat</title>
  <script src="https://cdn.botframework.com/botframework-webchat/latest/webchat.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      font-family: 'Segoe UI', sans-serif;
    }

    #container {
      display: flex;
      flex-direction: column;
      height: 100%;
      width: 100%;
    }

    #webchat {
      flex: 1;
      width: 100%;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="webchat"></div>
  </div>

  <script>
    let directLine = null;
    let connectionSub = null;
    let lastIncidentId = null;
    const TOKEN_EXPIRY_TIME = 29 * 60 * 1000; // 29 minutes

    async function getTokenAndDomain() {
      const tokenEndpoint = 'https://ac9995b4c763e323b7d7f36b8dfee2.07.environment.api.powerplatform.com/powervirtualagents/botsbyschema/cr5d4_agent1/directline/token?api-version=2022-03-01-preview';
      const settingsEndpoint = 'https://ac9995b4c763e323b7d7f36b8dfee2.07.environment.api.powerplatform.com/powervirtualagents/regionalchannelsettings?api-version=2022-03-01-preview';

      const tokenRes = await fetch(tokenEndpoint);
      const { token } = await tokenRes.json();

      const settingsRes = await fetch(settingsEndpoint);
      const { channelUrlsById: { directline } } = await settingsRes.json();

      const domain = new URL('v3/directline', directline).toString();
      return { token, domain, tokenTimestamp: Date.now() };
    }

    async function startWebChat(payload) {
      const { incidentId } = payload;
      const cacheKey = `chat_${incidentId}`;
      const cachedData = JSON.parse(sessionStorage.getItem(cacheKey) || '{}');

      let token = cachedData.token;
      let domain = cachedData.domain;
      let conversationId = cachedData.conversationId;
      const tokenTimestamp = cachedData.tokenTimestamp || 0;

      const isOldIncident = incidentId !== lastIncidentId;
      const isTokenValid = token && (Date.now() - tokenTimestamp < TOKEN_EXPIRY_TIME);

      // CASE: Switching to a new incident tab — always get a fresh token
      // CASE: Switching back to old incident tab — reuse if token valid, else fetch new
      if ( isOldIncident || !isTokenValid ) {
        console.log("Trace - Fetching NEW token for incident:", incidentId);
        const auth = await getTokenAndDomain();
        token = auth.token;
        domain = auth.domain;
        conversationId = null; // new token invalidates old conversation
        sessionStorage.setItem(cacheKey, JSON.stringify({
          token,
          domain,
          tokenTimestamp: auth.tokenTimestamp
        }));
      } else {
        console.log("Trace - Reusing cached token for incident:", incidentId);
      }

      await cleanUpChat();

      directLine = window.WebChat.createDirectLine({
        token,
        domain,
        ...(conversationId ? { conversationId } : {})
      });

      connectionSub = directLine.connectionStatus$.subscribe(status => {
        if (status === 2) {
          if (!conversationId && directLine.conversationId) {
            // Store updated conversationId
            const updated = JSON.parse(sessionStorage.getItem(cacheKey) || '{}');
            updated.conversationId = directLine.conversationId;
            sessionStorage.setItem(cacheKey, JSON.stringify(updated));
          }

          directLine.postActivity({
            type: 'event',
            name: 'startConversation',
            from: { id: 'user_1' },
            value: { incidentId }
          }).subscribe(() => {
            console.log("Trace - startConversation event sent with:", payload);
          });

          connectionSub.unsubscribe();
        }
      });

      window.WebChat.renderWebChat(
        {
          directLine,
          userID: 'user_1',
          locale: 'en',
          styleOptions: { hideUploadButton: false }
        },
        document.getElementById('webchat')
      );

      console.log('Trace - Bot rendered for incident:', incidentId);
      lastIncidentId = incidentId;
    }

    async function cleanUpChat() {
      if (connectionSub) {
        connectionSub.unsubscribe();
        connectionSub = null;
      }

      if (directLine && directLine.end) {
        try {
          directLine.end();
        } catch (e) {
          console.warn("Error ending DirectLine", e);
        }
        directLine = null;
      }

      const oldWebchat = document.getElementById('webchat');
      if (oldWebchat) oldWebchat.remove();

      const newWebchat = document.createElement('div');
      newWebchat.id = 'webchat';
      document.getElementById('container').appendChild(newWebchat);
    }

    // Handle OpenFrame messaging from ServiceNow
    window.addEventListener("message", async (event) => {
      try {
        const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
        console.log("Trace - message received", data);

        if (!["openframe_communication", "openframe_hidden"].includes(data?.eventName)) return;

        let incidentId = null;

        if (data.eventName === "openframe_communication") {
          const args = JSON.parse(data.args);
          incidentId = args.recordId || extractIncidentIdFromUrl(args.url);
        } else if (data.eventName === "openframe_hidden") {
          incidentId = lastIncidentId;
          console.warn("Trace - Using last known incident ID");
        }

        if (!incidentId) {
          console.warn("Trace - No incident ID found");
          return;
        }

        const payload = {
          locale: 'en',
          localTimezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          incidentId
        };

        await startWebChat(payload);

      } catch (e) {
        console.error("Trace - Failed to handle OpenFrame message", e);
      }
    });

    function extractIncidentIdFromUrl(url) {
      const match = url?.match(/incident\/([a-f0-9]+)/i);
      return match ? match[1] : null;
    }

    console.log("Trace - Waiting for ServiceNow context...");
  </script>
</body>
</html>
